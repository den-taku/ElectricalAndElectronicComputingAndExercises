\documentclass[uplatex, 11pt,a4j, titlepage]{jsarticle}

\usepackage{assets/preamble}
\usepackage{assets/info}
\usepackage{listings,jlisting}

% Title
\title{第1回 演習課題}
\date{2020年 10月 29日}
\author{
    \small{\myid} \\
    \myname\thanks{\mymail}
}

\begin{document}
\maketitle

% 実験レポート1
% ここから

\subtitle{2020/10/8}

\theme{課題1.1}

二分法およびニュートン法を用いて非線形方程式を解くプログラムを
それぞれソースコード1、ソースコード2に示す。

\ 

まず二分法を用いたソースコード1について説明する。

bisection\_method 関数は、引数としてrange、e、f、expected\_valueを受け取る。
これらはそれぞれ範囲、許容誤差、関数、真値である。
まず初期区間をrangeとして与えると、bisection\_methodは
bisection\_method\_inner関数にrange、e、f、expected\_valueを渡し、さらに
回数としてtimesに1を、また反復回数と近似解のデータを書き込むバッファdataを渡す。
bisection\_method\_inner関数は範囲を半分に区切り、解が存在すると思われる範囲を
再帰的に渡してtimesを一つ進める。
この時その範囲が許容誤差内に収まったなら、半分に区切った時の値を近似解として返す。

\ 

次にニュートン法を用いたソースコード2について説明する。

まず、ニュートン法で非線形方程式を解くには関数を微分する必要がある。
関数の微分には、微分係数の定義である
\begin{equation}
    \lim_{h \to 0} \frac{f(x + h) - f(x)}{h}   
\end{equation}
を用いて微分した関数を返すdifferential\_f関数を作成した。

newton\_raphson\_method関数は次のようなアルゴリズムで方程式を解く。
まず、関数には$f(x)$と初期近似解を与える。すると、その関数を微分し、
\begin{equation}
    g(x) = x - \frac{f(x)}{f'(x)}
\end{equation}
となる$g(x)$を計算するnewton\_transform関数に$f(x)$、$f'(x)$を渡し、
また閾値と回数として1、反復回数上限として1,000,000、バッファとしてのdata、
真値expected\_valueとともに
newton\_method関数に渡す。

newton\_method関数では、$g(x)$を用いて近似解の候補を求め、元の$x$との
距離が閾値よりも小さい時、その計算した値を近似解として返す。閾値よりも大きかった場合は
計算した値を再帰的にnewton\_methodに渡す。それを繰り返すことで非線形方程式を解く。
最初にnextの値をチェックしているのは、$g(x)$の値が想定していない値になった時の処理を
まとめてあるだけであり、アルゴリズムに直接は影響しない。これについては後で言及する。


なお、バッファに保存したdataはgnuplotを用いて描画する。

\ 

\begin{lstlisting}[caption={bisection\_method.rs}]

#![allow(dead_code)]

pub use std::ops::Range;
pub use std::rc::Rc;
    
pub fn bisection_method(
    range: Range<f64>,
    e: f64,
    f: Rc<dyn Fn(f64) -> f64>,
    expected_value: f64,
) -> (f64, Vec<(f64, f64)>) {
    let data: Vec<(f64, f64)> = Vec::new();
    bisection_method_inner(
        range, e, f, 1, expected_value, data
    )
}
    
fn bisection_method_inner(
    mut range: Range<f64>,
    e: f64,
    f: Rc<dyn Fn(f64) -> f64>,
    times: usize,
    expected_value: f64,
    mut data: Vec<(f64, f64)>,
) -> (f64, Vec<(f64, f64)>) {
    let x_new = (range.end + range.start) / 2.;
    if f(x_new) * f(range.start) >= 0. {
        range.start = x_new;
    } else {
        range.end = x_new;
    }
    data.push((times as f64, (x_new - expected_value).abs()));
    if range.end - range.start <= e {
        (x_new, data)
    } else {
        bisection_method_inner(
            range, e, f, times + 1, expected_value, data
        )
    }
}
    
#[cfg(test)]
mod tests_bisection_method {
    use crate::bisection_method::*;
    
    #[test]
    fn tests_bisection_method() {
        let f = Rc::new(|x: f64| {
            x.powf(5.) - 3. * x.powf(4.) + x.powf(3.) 
                + 5. * x.powf(2.) - 6. * x + 2.
        });
        assert_eq!(
            (bisection_method(
                -2f64..0f64, 1e-3, f.clone(), -1.414213566237)
            ).0,
            -1.4150390625
        );
        assert_eq!(
            (bisection_method(
                -2f64..0f64, 1e-4, f.clone(), -1.414213566237)
            ).0,
            -1.41424560546875
        );
        assert_eq!(
            (bisection_method(
                -2f64..0f64, 1e-5, f.clone(), -1.414213566237)
            ).0,
            -1.4142074584960938
        );
    }
}

\end{lstlisting}

\begin{lstlisting}[caption={newton\_raphson\_method.rs}]
#![allow(dead_code)]

// pub mod newton_raphson_method {
pub use std::rc::Rc;
pub use std::result::Result;
    
pub fn newton_raphson_method(
    f: Rc<dyn Fn(f64) -> f64>,
    init: f64,
    expected_value: f64,
) -> Result<(f64, Vec<(f64, f64)>), String> {
    let threshold = 0.1e-10;
    let f_dir = differential_f(f.clone()); 
    let data: Vec<(f64, f64)> = Vec::new();
    newton_method(
        newton_transform(f, f_dir),
        init,
        threshold,
        1,
        1_000_000,
        expected_value,
        data,
    )
}
    
fn differential_f(
    f: Rc<dyn Fn(f64) -> f64>
) -> Rc<dyn Fn(f64) -> f64> {
    let dx = 0.1e-10;
    let f_dir = move |x: f64| -> f64 { (f(x + dx) - f(x)) / dx };
    Rc::new(f_dir)
}
    
unsafe fn partial_derivative(
    f: Rc<dyn Fn(Vec<f64>) -> f64>,
    i: usize,
) -> Rc<dyn Fn(Vec<f64>) -> f64> {
    let dx = 0.1e-10;
    let f_der = move |v: Vec<f64>| -> f64 {
        let mut v_dx = v.clone();
        v_dx[i] += dx;
        (f(v_dx) - f(v)) / dx
    };
    Rc::new(f_der)
}
    
fn newton_transform(
    f: Rc<dyn Fn(f64) -> f64>,
    f_dir: Rc<dyn Fn(f64) -> f64>,
) -> Rc<dyn Fn(f64) -> f64> {
    Rc::new(move |x: f64| -> f64 { x - f(x) / f_dir(x) })
}
    
fn newton_method(
    f: Rc<dyn Fn(f64) -> f64>,
    guess: f64,
    threshold: f64,
    times: usize,
    limit: usize,
    expected_value: f64,
    mut data: Vec<(f64, f64)>,
) -> Result<(f64, Vec<(f64, f64)>), String> {
    let next = f(guess);
    if next == f64::NEG_INFINITY 
    || next == f64::INFINITY 
    || next.is_nan() {
        return Err(format!(
            "x^(k+1) is not a number: last value is {}.", guess)
        );
    }
    if limit == times + 1 {
        return Err(format!(
            "solution doesn't converge: last value is {}.",
            next
        ));
    }
    data.push((times as f64, (next - expected_value).abs()));
    if (next - guess).abs() <= threshold {
        Ok((next, data))
    } else {
        newton_method(
            f, next, threshold, times + 1, 
            limit, expected_value, data
        )
    }
}
    
#[cfg(test)]
mod tests_newton_raphson_method {
    use crate::newton_raphson_method::newton_method;
    use crate::newton_raphson_method::*;
    
    #[test]
    fn test_newton_raphson_method_newton_raphson_method() {
        let f: Rc<dyn Fn(f64) -> f64> = Rc::new(|x: f64| -> f64 {
            x.powf(5.) - 3. * x.powf(4.) + x.powf(3.) 
                + 5. * x.powf(2.) - 6. * x + 2.
        });
        assert_eq!(
            newton_raphson_method(f, -1., -1.414213566237).unwrap().0,
            -1.4142135623730951
        );
    }
    
    #[test]
    fn test_newton_raphson_method_newton_method_neg_inf() {
        let f: Rc<dyn Fn(f64) -> f64> = Rc::new(|x: f64| -> f64 { x });
        assert_eq!(
            newton_method(
                f,
                f64::NEG_INFINITY,
                0.1e-10,
                1,
                10000,
                -1.41,
                vec![(0f64, 0f64)]
            ),
            Err("x^(k+1) is not a number: last value is -inf.".to_string())
        );
    }
    
    #[test]
    fn test_newton_raphson_method_newton_method_inf() {
        let f: Rc<dyn Fn(f64) -> f64> = Rc::new(|x: f64| -> f64 { x });
        assert_eq!(
            newton_method(
                f,
                f64::INFINITY,
                0.1e-10,
                1,
                10000,
                -1.41,
                vec![(0f64, 0f64)]
            ),
            Err("x^(k+1) is not a number: last value is inf.".to_string())
        );
    }
    
    #[test]
    fn test_newton_raphson_method_newton_method_nan() {
        let f: Rc<dyn Fn(f64) -> f64> = Rc::new(|x: f64| -> f64 { x });
        assert_eq!(
            newton_method(f, f64::NAN, 0.1e-10, 1, 10000, -1.41, vec![(0f64, 0f64)]),
            Err("x^(k+1) is not a number: last value is NaN.".to_string())
        );
    }
} 
\end{lstlisting}


\section{課題1.1.1}
\begin{equation}
    f(x) = x^5 - 3 x^4 + x^3 + 5 x^2 - 6x + 2 
\end{equation}
とする。
5次方程式$f(x) = 0$の解を最初に説明した二分法およびニュートン法を用いた
プログラムを実行して解く。


二分法の初期期間を[-2, 0]とし、ニュートン法の初期近似解を-1とする。
そして反復回数を横軸に、
それぞれの手法で得られた近似解と真値($-\sqrt{2}$)との誤差の絶対値を縦軸にとった
片対数グラフをそれぞれ図\label{bis_new}に作成し、示す。



図\ref{bis_new}より、二分法(青色)は収束にこそ時間がかかるが
比較的誤差の大きさは小さいので初めからある程度は真値近くの値を示すのに対し、
ニュートン法では収束の速さが速いが収束する前は真値とよりかけ離れた値を
解の候補として提示することがわかる。

これは、二分法がもともと限られた範囲を二分していくためそこまで誤差が大きくなく
安定して解に収束していくのに対し、
ニュートン法では関数の形に依存する。
今回のグラフでは収束の様子が図\ref{new}のように観測できた。
このグラフでは候補の点の接線が$x$軸と交わった点が次の候補点になる様子が
わかった。

\begin{figure}[h]
    \centering
    \includegraphics[width=12cm]{speed_bis_new.pdf}
    \caption{二分法・ニュートン法の収束の速さ}
    \label{bis_new}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=12cm]{speed_new.pdf}
    \caption{ニュートン法による収束の様子}
    \label{new}
\end{figure}

\newpage
\newpage

\section{課題1.1.2}

二分法の初期区間を[0, 1.2]、ニュートン法の初期近似解を-0.6として
課題1.1.1と同様のグラフを作成しようとしたところ、
newton\_raphson\_methodが、
"x\^(k+1) is not a number: last value is 0.9964477602428009."
というエラーを吐いて以上終了した。これは0除算を行う等の演算により、値が
正常な値にならない時にRustでは値がNaNになるため、その時に吐き出すように
設定したエラーメッセージである。
ここで、エラー時にエラーメッセージを吐くのではなく、
バッファのdataを返すようにして値をプロットしたグラフが
図\ref{new_err}になる。

これは、ニュートン法の暗黙の仮定を破ったことによるエラーだと考えた。
求めるべき解の真値は-1だが、これは$f(x)$の重解になっている。
したがって解の近傍では$f(x)$、$f'(x)$の双方が共にゼロに近づき、
今回は$f'(x)$の方が0に収束するのが速く、値が不正なものになってしまったのだと
考えた。

\newpage
\begin{figure}[h]
    \centering
    \includegraphics[width=12cm]{new_err.pdf}
    \caption{エラー終了するまでの値}
    \label{new_err}
\end{figure}

% 実験レポート1
% ここまで

\newpage
% \resetcounters

% 実験レポート2
% ここから

\subtitle{2020/10/*}

\theme{課題1.2}
\section{課題1.2.1}
\section{課題1.2.2}
\section{課題1.2.3}
% 実験レポート2
% ここまで

\newpage
% \resetcounters


% 実験レポート3
% ここから

\subtitle{2019/*/*}

\theme{課題1.3}
\section{課題1.3.1}
\section{課題1.3.2}

% 実験レポート3
% ここまで

% 参考文献
\newpage
\thispagestyle{empty}
\nocite{key1}
\nocite{key2}
\bibliographystyle{junsrt}
\bibliography{assets/ref}

\end{document}