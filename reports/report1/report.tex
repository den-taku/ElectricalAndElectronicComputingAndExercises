\documentclass[uplatex, 11pt,a4j, titlepage]{jsarticle}

\usepackage{assets/preamble}
\usepackage{assets/info}
\usepackage{listings,jlisting}

% Title
\title{第1回 演習課題}
\date{2020年 10月 29日}
\author{
    \small{\myid} \\
    \myname\thanks{\mymail}
}

\begin{document}
\maketitle

% 実験レポート1
% ここから

\subtitle{2020/10/8}

\theme{課題1.1}

二分法およびニュートン法を用いて非線形方程式を解くプログラムを
それぞれソースコード1、ソースコード2に示す。

\ 

まず二分法を用いたソースコード1について説明する。

bisection\_method 関数は、引数としてrange、e、fを受け取る。
これらはそれぞれ範囲、許容誤差、関数である。
まず初期区間をrangeとして与えると、bisection\_methodは
bisection\_method\_inner関数にrange、e、fを渡し、さらに
回数としてtimesに1を、反復回数上限値としてlimitに1,000,000を与える。
二分法は適切に初期区間を与えると必ず近似解が求まるためlimitはオプションである。
bisection\_method\_inner関数は範囲を半分に区切り、解が存在すると思われる範囲を
再帰的に渡してtimesを一つ進める。
この時その範囲が許容誤差内に収まったなら、半分に区切った時の値を近似解として返す。
ソースコード中に含まれるprintln!関数は、
課題で反復回数と誤差のcsvファイルを作成するために
標準出力に値を渡しているだけで求解に直接は影響しない。

\ 

次にニュートン法を用いたソースコード2について説明する。

まず、ニュートン法で非線形方程式を解くには関数を微分する必要がある。
関数の微分には、微分係数の定義である
\begin{equation}
    \lim_{h \to 0} \frac{f(x + h) - f(x)}{h}   
\end{equation}
を用いて微分した関数を返すdifferential\_f関数を作成した。

newton\_raphson\_method関数は次のようなアルゴリズムで方程式を解く。
まず、関数には$f(x)$と初期近似解を与える。すると、その関数を微分し、
\begin{equation}
    g(x) = x - \frac{f(x)}{f'(x)}
\end{equation}
となる$g(x)$を計算するnewton\_transform関数に$f(x)$、$f'(x)$を渡し、
また閾値と回数として1、反復回数上限として1,000,000とともに
newton\_method関数に渡す。

newton\_method関数では、$g(x)$を用いて近似解の候補を求め、元の$x$との
距離が閾値よりも小さい時、その計算した値を近似解として返す。閾値よりも大きかった場合は
計算した値を再帰的にnewton\_methodに渡す。それを繰り返すことで非線形方程式を解く。
最初にnextの値をチェックしているのは、$g(x)$の値が想定していない値になった時の処理を
まとめてあるだけであり、アルゴリズムに直接は影響しない。これについては後で言及する。

ここでも後で値をplotするためにprintln!関数を用いて標準出力に値を渡している。

\ 

\begin{lstlisting}[caption={bisection\_method.rs}]

use std::ops::Range;
use std::rc::Rc;
     
fn bisection_method(
    mut range: Range<f64>, 
    e: f64, 
    f: Rc<dyn Fn(f64) -> f64>
)-> f64 {
    bisection_method_inner(range, e, f, 1, 1000000)
}
     
fn bisection_method_inner(
    mut range: Range<f64>,
    e: f64,
    f: Rc<dyn Fn(f64) -> f64>,
    times: usize,
    limit: usize,
) -> f64 {
    let x_new = (range.end + range.start) / 2.;
    if times == limit {
        return x_new;
    }
    if f(x_new) * f(range.start) >= 0. {
        range.start = x_new;
    } else {
        range.end = x_new;
    }
    println!("{}, {}", times, (x_new - 1.414213566237).abs()); 
    if range.end - range.start <= e {
        x_new
    } else {
        bisection_method_inner(range, e, f, times + 1, limit)
    }
}

\end{lstlisting}

\begin{lstlisting}[caption={newton\_raphson\_method.rs}]
use std::rc::Rc;
use std::result::Result;
         
fn newton_raphson_method(
    f: Rc<dyn Fn(f64) -> f64>, 
    init: f64
) -> Result<f64, String> {
    let threshold = 0.1e-10;
    let f_dir = differential_f(f.clone()); 
    newton_method(newton_transform(f, f_dir), 
                  init, 
                  threshold, 
                  1, 
                  1000000)
}
        
fn differential_f(f: Rc<dyn Fn(f64) -> f64>) 
    -> Rc<dyn Fn(f64) -> f64> {
    let dx = 0.1e-10;
    let f_dir = move |x: f64| 
                    -> f64 { (f(x + dx) - f(x)) / dx };
    Rc::new(f_dir)
}
        
fn newton_transform(
    f: Rc<dyn Fn(f64) -> f64>,
    f_dir: Rc<dyn Fn(f64) -> f64>,
) -> Rc<dyn Fn(f64) -> f64> {
    Rc::new(move |x: f64| -> f64 { x - f(x) / f_dir(x) })
}
        
fn newton_method(
    f: Rc<dyn Fn(f64) -> f64>,
    guess: f64,
    threshold: f64,
    times: usize,
    limit: usize,
) -> Result<f64, String> {
    let next = f(guess);
    if next == f64::NEG_INFINITY 
    || next == f64::INFINITY 
    || next.is_nan() {
        return Err(
            format!(
                "x^(k+1) is not a number: last value is {}.", 
                guess
        ));
    }
    if limit == times + 1 {
        return Err(format!(
            "solution doesn't converge: last value is {}.",
            next
        ));
    }
    if (next - guess).abs() <= threshold {
        Ok(next)
    } else {
        println!("{}, {},", times, (next - 1.414213566237).abs());
        newton_method(f, next, threshold, times + 1, limit)
    }
} 
\end{lstlisting}


\section{課題1.1.1}
\begin{equation}
    f(x) = x^5 - 3 x^4 + x^3 + 5 x^2 - 6x + 2 
\end{equation}
とする。
5次方程式$f(x) = 0$の解を最初に説明した二分法およびニュートン法を用いた
プログラムを実行して解く。


二分法の初期期間を[-2, 0]とし、ニュートン法の初期近似解を-1とする。
そして反復回数を横軸に、
それぞれの手法で得られた近似解と真値($\sqrt{2}$)との誤差の絶対値を縦軸にとった
片対数グラフをそれぞれ図1、図2に作成し、示す。

\begin{figure}[h]
    \centering
    \includegraphics[width=12cm]{bisection_111.pdf}
    \caption{二分法の収束の速さ}
\end{figure}

\section{課題1.1.2}


% 実験レポート1
% ここまで

\newpage
% \resetcounters

% 実験レポート2
% ここから

\subtitle{2020/10/*}

\theme{課題1.2}
\section{課題1.2.1}
\section{課題1.2.2}
\section{課題1.2.3}
% 実験レポート2
% ここまで

\newpage
% \resetcounters


% 実験レポート3
% ここから

\subtitle{2019/*/*}

\theme{課題1.3}
\section{課題1.3.1}
\section{課題1.3.2}

% 実験レポート3
% ここまで

% 参考文献
\newpage
\thispagestyle{empty}
\nocite{key1}
\nocite{key2}
\bibliographystyle{junsrt}
\bibliography{assets/ref}

\end{document}